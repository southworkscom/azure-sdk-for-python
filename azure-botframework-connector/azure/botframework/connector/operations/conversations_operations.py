# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------

from msrest.pipeline import ClientRawResponse
from msrest.exceptions import HttpOperationError

from .. import models


class ConversationsOperations(object):
    """ConversationsOperations operations.

    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = models

    def __init__(self, client, config, serializer, deserializer):

        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer

        self.config = config

    def create_conversation(
            self, parameters, custom_headers=None, raw=False, **operation_config):
        """CreateConversation.

        Create a new Conversation.
        POST to this method with a
        * Bot being the bot creating the conversation
        * IsGroup set to true if this is not a direct message (default is
        false)
        * Members array containing the members you want to have be in the
        conversation.
        The return value is a ResourceResponse which contains a conversation id
        which is suitable for use
        in the message payload and REST API uris.
        Most channels only support the semantics of bots initiating a direct
        message conversation.  An example of how to do that would be:
        ```
        var resource = await connector.conversations.CreateConversation(new
        ConversationParameters(){ Bot = bot, members = new ChannelAccount[] {
        new ChannelAccount("user1") } );
        await connect.Conversations.SendToConversationAsync(resource.Id, new
        Activity() ... ) ;
        ```.

        :param parameters: Parameters to create the conversation from.
        :type parameters:
         ~azure.botframework.connector.models.ConversationParameters
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v3/conversations'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(parameters, 'ConversationParameters')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200, 201, 202, 400, 401, 403, 404, 405, 429, 500, 503]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ConversationResourceResponse', response)
        if response.status_code == 201:
            deserialized = self._deserialize('ConversationResourceResponse', response)
        if response.status_code == 202:
            deserialized = self._deserialize('ConversationResourceResponse', response)
        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 405:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 500:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 503:
            deserialized = self._deserialize('ErrorResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def send_to_conversation(
            self, conversation_id, activity, custom_headers=None, raw=False, **operation_config):
        """SendToConversation.

        This method allows you to send an activity to the end of a
        conversation.
        This is slightly different from ReplyToActivity.
        * SendToConversation - will append the activity to the end of the
        conversation according to the timestamp or semantics of the channel.
        * ReplyToActivity - adds the activity as a reply to another activity,
        if the channel supports it. If the channel does not support nested
        replies, ReplyToActivity falls back to SendToConversation.
        Use ReplyToActivity when replying to a specific activity in the
        conversation.
        Use SendToConversation in all other cases.

        :param conversation_id: Conversation ID.
        :type conversation_id: str
        :param activity: Activity to send.
        :type activity: ~azure.botframework.connector.models.Activity
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v3/conversations/{conversationId}/activities'
        path_format_arguments = {
            'conversationId': self._serialize.url("conversation_id", conversation_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(activity, 'Activity')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200, 201, 202, 400, 401, 403, 404, 429, 500, 503]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ResourceResponse', response)
        if response.status_code == 201:
            deserialized = self._deserialize('ResourceResponse', response)
        if response.status_code == 202:
            deserialized = self._deserialize('ResourceResponse', response)
        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 500:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 503:
            deserialized = self._deserialize('ErrorResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_activity(
            self, conversation_id, activity_id, activity, custom_headers=None, raw=False, **operation_config):
        """UpdateActivity.

        Edit an existing activity.
        Some channels allow you to edit an existing activity to reflect the new
        state of a bot conversation.
        For example, you might remove buttons from a message in the
        conversation after the user has clicked one of the buttons. If
        successful, this operation updates the specified activity within the
        specified conversation.

        :param conversation_id: Conversation ID.
        :type conversation_id: str
        :param activity_id: Activity Id to update.
        :type activity_id: str
        :param activity: replacement Activity.
        :type activity: ~azure.botframework.connector.models.Activity
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v3/conversations/{conversationId}/activities/{activityId}'
        path_format_arguments = {
            'conversationId': self._serialize.url("conversation_id", conversation_id, 'str'),
            'activityId': self._serialize.url("activity_id", activity_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(activity, 'Activity')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200, 201, 202, 400, 401, 403, 404, 405, 429, 500, 503]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ResourceResponse', response)
        if response.status_code == 201:
            deserialized = self._deserialize('ResourceResponse', response)
        if response.status_code == 202:
            deserialized = self._deserialize('ResourceResponse', response)
        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 405:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 500:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 503:
            deserialized = self._deserialize('ErrorResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def reply_to_activity(
            self, conversation_id, activity_id, activity, custom_headers=None, raw=False, **operation_config):
        """ReplyToActivity.

        This method allows you to reply to an activity.
        This is slightly different from SendToConversation().
        * SendToConversation - will append the activity to the end of the
        conversation according to the timestamp or semantics of the channel.
        * ReplyToActivity - adds the activity as a reply to another activity,
        if the channel supports it. If the channel does not support nested
        replies, ReplyToActivity falls back to SendToConversation.
        Use ReplyToActivity when replying to a specific activity in the
        conversation.
        Use SendToConversation in all other cases.

        :param conversation_id: Conversation ID.
        :type conversation_id: str
        :param activity_id: ID of the activity.
        :type activity_id: str
        :param activity: Activity to send.
        :type activity: ~azure.botframework.connector.models.Activity
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v3/conversations/{conversationId}/activities/{activityId}'
        path_format_arguments = {
            'conversationId': self._serialize.url("conversation_id", conversation_id, 'str'),
            'activityId': self._serialize.url("activity_id", activity_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(activity, 'Activity')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200, 201, 202, 400, 401, 403, 404, 429, 500, 503]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ResourceResponse', response)
        if response.status_code == 201:
            deserialized = self._deserialize('ResourceResponse', response)
        if response.status_code == 202:
            deserialized = self._deserialize('ResourceResponse', response)
        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 500:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 503:
            deserialized = self._deserialize('ErrorResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_activity(
            self, conversation_id, activity_id, custom_headers=None, raw=False, **operation_config):
        """DeleteActivity.

        Delete an existing activity.
        Some channels allow you to delete an existing activity. If successful,
        this operation removes the specified activity from the specified
        conversation.

        :param conversation_id: Conversation ID.
        :type conversation_id: str
        :param activity_id: ID of activity to delete.
        :type activity_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ErrorResponse or ClientRawResponse if raw=true
        :rtype: ~azure.botframework.connector.models.ErrorResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v3/conversations/{conversationId}/activities/{activityId}'
        path_format_arguments = {
            'conversationId': self._serialize.url("conversation_id", conversation_id, 'str'),
            'activityId': self._serialize.url("activity_id", activity_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200, 202, 400, 401, 403, 404, 405, 429, 500, 503]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 405:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 500:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 503:
            deserialized = self._deserialize('ErrorResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_conversation_members(
            self, conversation_id, custom_headers=None, raw=False, **operation_config):
        """GetConversationMembers.

        Enumerate the members of a conversation.
        This REST API takes a Conversation ID and returns an array of
        ChannelAccount objects representing the members of the conversation.

        :param conversation_id: Conversation ID.
        :type conversation_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v3/conversations/{conversationId}/members'
        path_format_arguments = {
            'conversationId': self._serialize.url("conversation_id", conversation_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200, 400, 401, 403, 404, 405, 429, 500, 503]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[ChannelAccount]', response)
        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 405:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 500:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 503:
            deserialized = self._deserialize('ErrorResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_activity_members(
            self, conversation_id, activity_id, custom_headers=None, raw=False, **operation_config):
        """GetActivityMembers.

        Enumerate the members of an activity.
        This REST API takes a Conversation ID and an Activity ID, returning an
        array of ChannelAccount objects representing the members of the
        particular activity in the conversation.

        :param conversation_id: Conversation ID.
        :type conversation_id: str
        :param activity_id: Activity ID.
        :type activity_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v3/conversations/{conversationId}/activities/{activityId}/members'
        path_format_arguments = {
            'conversationId': self._serialize.url("conversation_id", conversation_id, 'str'),
            'activityId': self._serialize.url("activity_id", activity_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200, 400, 401, 403, 404, 405, 429, 500, 503]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[ChannelAccount]', response)
        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 405:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 500:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 503:
            deserialized = self._deserialize('ErrorResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def upload_attachment(
            self, conversation_id, attachment_upload, custom_headers=None, raw=False, **operation_config):
        """UploadAttachment.

        Upload an attachment directly into a channel's blob storage.
        This is useful because it allows you to store data in a compliant store
        when dealing with enterprises.
        The response is a ResourceResponse which contains an Attachment ID
        which is suitable for using with the attachments API.

        :param conversation_id: Conversation ID.
        :type conversation_id: str
        :param attachment_upload: Attachment data.
        :type attachment_upload:
         ~azure.botframework.connector.models.AttachmentData
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v3/conversations/{conversationId}/attachments'
        path_format_arguments = {
            'conversationId': self._serialize.url("conversation_id", conversation_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(attachment_upload, 'AttachmentData')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200, 201, 202, 400, 401, 403, 404, 405, 429, 500, 503]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ResourceResponse', response)
        if response.status_code == 201:
            deserialized = self._deserialize('ResourceResponse', response)
        if response.status_code == 202:
            deserialized = self._deserialize('ResourceResponse', response)
        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 405:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 500:
            deserialized = self._deserialize('ErrorResponse', response)
        if response.status_code == 503:
            deserialized = self._deserialize('ErrorResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
